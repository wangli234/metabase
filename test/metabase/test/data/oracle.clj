(ns metabase.test.data.oracle
  (:require [clojure.java.jdbc :as jdbc]
            [clojure.string :as s]
            [environ.core :refer [env]]
            [metabase.test.data.interface :as tx]
            [metabase.driver.sql.query-processor :as sql.qp]
            [metabase.test.data.sql :as sql.tx]
            [metabase.test.data.sql-jdbc :as sql-jdbc.tx]
            [metabase.test.data.sql.ddl :as ddl]
            [metabase.test.data.sql-jdbc.spec :as spec]
            [metabase.test.data.sql-jdbc.execute :as execute]
            [metabase.test.data.sql-jdbc.load-data :as load-data]
            [metabase.util :as u]
            [metabase.driver.sql-jdbc.connection :as sql-jdbc.conn]))

(sql-jdbc.tx/add-test-extensions! :oracle)

;; Similar to SQL Server, Oracle on AWS doesn't let you create different databases;
;; We'll create a unique schema (the same as a "User" in Oracle-land) for each test run and use that to keep
;; tests from clobbering over one another; we'll also qualify the names of tables to include their DB name
;;
;; e.g.
;; H2 Tests                   | Oracle Tests
;; ---------------------------+------------------------------------------------
;; PUBLIC.VENUES.ID           | CAM_195.test_data_venues.id
;; PUBLIC.CHECKINS.USER_ID    | CAM_195.test_data_checkins.user_id
;; PUBLIC.INCIDENTS.TIMESTAMP | CAM_195.sad_toucan_incidents.timestamp
(defonce ^:private ^:const session-schema-number (rand-int 200))
(defonce ^:private ^:const session-schema        (str "CAM_" session-schema-number))
(defonce ^:private ^:const session-password      (apply str (repeatedly 16 #(rand-nth (map char (range (int \a) (inc (int \z))))))))

(def ^:private connection-details
  (delay
   {:host     (tx/db-test-env-var-or-throw :oracle :host)
    :port     (Integer/parseInt (tx/db-test-env-var-or-throw :oracle :port "1521"))
    :user     (tx/db-test-env-var-or-throw :oracle :user)
    :password (tx/db-test-env-var-or-throw :oracle :password)
    :sid      (tx/db-test-env-var-or-throw :oracle :sid)}))

(defmethod tx/database->connection-details :oracle [_ _ _]
  @connection-details)

(defmethod sql.tx/field-base-type->sql-type [:oracle :type/BigInteger] [_ _] "NUMBER(*,0)")
(defmethod sql.tx/field-base-type->sql-type [:oracle :type/Boolean]    [_ _] "NUMBER(1)")
(defmethod sql.tx/field-base-type->sql-type [:oracle :type/Date]       [_ _] "DATE")
(defmethod sql.tx/field-base-type->sql-type [:oracle :type/DateTime]   [_ _] "TIMESTAMP")
(defmethod sql.tx/field-base-type->sql-type [:oracle :type/Decimal]    [_ _] "DECIMAL")
(defmethod sql.tx/field-base-type->sql-type [:oracle :type/Float]      [_ _] "BINARY_FLOAT")
(defmethod sql.tx/field-base-type->sql-type [:oracle :type/Integer]    [_ _] "INTEGER")
(defmethod sql.tx/field-base-type->sql-type [:oracle :type/Text]       [_ _] "VARCHAR2(4000)")

(defmethod sql.tx/drop-table-if-exists-sql :oracle [_ {:keys [database-name]} {:keys [table-name]}]
  (format "BEGIN
             EXECUTE IMMEDIATE 'DROP TABLE \"%s\".\"%s\" CASCADE CONSTRAINTS'⅋
           EXCEPTION
             WHEN OTHERS THEN
               IF SQLCODE != -942 THEN
                 RAISE⅋
               END IF⅋
           END⅋"
          session-schema
          (tx/db-qualified-table-name database-name table-name)))

(defmethod tx/expected-base-type->actual :oracle [_ base-type]
  ;; Oracle doesn't have INTEGERs
  (if (isa? base-type :type/Integer)
    :type/Decimal
    base-type))

(defmethod sql.tx/create-db-sql :oracle [_ _] nil)

(defmethod sql.tx/drop-db-if-exists-sql :oracle [_ _ _] nil)

(defmethod execute/execute-sql! :oracle [driver context dbdef sql]
  (execute/sequentially-execute-sql! driver context dbdef sql))

;; Now that connections are reüsed doing this sequentially actually seems to be faster than parallel
(defmethod load-data/load-data! :oracle [driver dbdef tabledef]
  (load-data/load-data-one-at-a-time! driver dbdef tabledef))

(defmethod sql.tx/pk-sql-type :oracle [_]
  "INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1) NOT NULL")

(defmethod tx/id-field-type :oracle [_] :type/Decimal)

(defmethod tx/has-questionable-timezone-support? :oracle [_] true)


;;; --------------------------------------------------- Test Setup ---------------------------------------------------

(defn- dbspec [& _]
  (sql-jdbc.conn/connection-details->spec :oracle @connection-details))

(defn- non-session-schemas
  "Return a set of the names of schemas (users) that are not meant for use in this test session (i.e., ones that should
  be ignored). (This is used as part of the implementation of `excluded-schemas` for the Oracle driver during tests.)"
  []
  (set (map :username (jdbc/query (dbspec) ["SELECT username FROM dba_users WHERE username <> ?" session-schema]))))


;;; Clear out the sesion schema before and after tests run
;; TL;DR Oracle schema == Oracle user. Create new user for session-schema
(def ^:private execute-when-testing-oracle!
  (partial sql-jdbc.tx/execute-when-testing! :oracle dbspec))

(defn- clean-session-schemas! []
  "Delete any old session users that for some reason or another were never deleted. For REPL usage."
  (doseq [schema (non-session-schemas)
          :when  (re-find #"^CAM_" schema)]
    (execute-when-testing-oracle! (format "DROP USER %s CASCADE" schema))))

(defn- create-session-user!
  {:expectations-options :before-run}
  []
  (u/ignore-exceptions
    (execute-when-testing-oracle! (format "DROP USER %s CASCADE" session-schema)))
  (execute-when-testing-oracle! (format "CREATE USER %s IDENTIFIED BY %s DEFAULT TABLESPACE USERS QUOTA UNLIMITED ON USERS" session-schema session-password)))

(defn- destroy-session-user!
  {:expectations-options :after-run}
  []
  (execute-when-testing-oracle! (format "DROP USER %s CASCADE" session-schema)))
